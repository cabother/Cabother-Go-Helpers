// Code generated by mockery v2.35.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gorm "gorm.io/gorm"

	sql "database/sql"
)

// MySQLService is an autogenerated mock type for the MySQLService type
type MySQLService struct {
	mock.Mock
}

type MySQLService_Expecter struct {
	mock *mock.Mock
}

func (_m *MySQLService) EXPECT() *MySQLService_Expecter {
	return &MySQLService_Expecter{mock: &_m.Mock}
}

// Begin provides a mock function with given fields: opts
func (_m *MySQLService) Begin(opts ...*sql.TxOptions) *gorm.DB {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...*sql.TxOptions) *gorm.DB); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Begin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Begin'
type MySQLService_Begin_Call struct {
	*mock.Call
}

// Begin is a helper method to define mock.On call
//   - opts ...*sql.TxOptions
func (_e *MySQLService_Expecter) Begin(opts ...interface{}) *MySQLService_Begin_Call {
	return &MySQLService_Begin_Call{Call: _e.mock.On("Begin",
		append([]interface{}{}, opts...)...)}
}

func (_c *MySQLService_Begin_Call) Run(run func(opts ...*sql.TxOptions)) *MySQLService_Begin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*sql.TxOptions, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(*sql.TxOptions)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_Begin_Call) Return(_a0 *gorm.DB) *MySQLService_Begin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MySQLService_Begin_Call) RunAndReturn(run func(...*sql.TxOptions) *gorm.DB) *MySQLService_Begin_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields:
func (_m *MySQLService) Commit() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type MySQLService_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *MySQLService_Expecter) Commit() *MySQLService_Commit_Call {
	return &MySQLService_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *MySQLService_Commit_Call) Run(run func()) *MySQLService_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MySQLService_Commit_Call) Return(_a0 *gorm.DB) *MySQLService_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MySQLService_Commit_Call) RunAndReturn(run func() *gorm.DB) *MySQLService_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// Connection provides a mock function with given fields: fc
func (_m *MySQLService) Connection(fc func(*gorm.DB) error) error {
	ret := _m.Called(fc)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*gorm.DB) error) error); ok {
		r0 = rf(fc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MySQLService_Connection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connection'
type MySQLService_Connection_Call struct {
	*mock.Call
}

// Connection is a helper method to define mock.On call
//   - fc func(*gorm.DB) error
func (_e *MySQLService_Expecter) Connection(fc interface{}) *MySQLService_Connection_Call {
	return &MySQLService_Connection_Call{Call: _e.mock.On("Connection", fc)}
}

func (_c *MySQLService_Connection_Call) Run(run func(fc func(*gorm.DB) error)) *MySQLService_Connection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(*gorm.DB) error))
	})
	return _c
}

func (_c *MySQLService_Connection_Call) Return(err error) *MySQLService_Connection_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MySQLService_Connection_Call) RunAndReturn(run func(func(*gorm.DB) error) error) *MySQLService_Connection_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with given fields: count
func (_m *MySQLService) Count(count *int64) *gorm.DB {
	ret := _m.Called(count)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(*int64) *gorm.DB); ok {
		r0 = rf(count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MySQLService_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - count *int64
func (_e *MySQLService_Expecter) Count(count interface{}) *MySQLService_Count_Call {
	return &MySQLService_Count_Call{Call: _e.mock.On("Count", count)}
}

func (_c *MySQLService_Count_Call) Run(run func(count *int64)) *MySQLService_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*int64))
	})
	return _c
}

func (_c *MySQLService_Count_Call) Return(tx *gorm.DB) *MySQLService_Count_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Count_Call) RunAndReturn(run func(*int64) *gorm.DB) *MySQLService_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: value
func (_m *MySQLService) Create(value interface{}) *gorm.DB {
	ret := _m.Called(value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MySQLService_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - value interface{}
func (_e *MySQLService_Expecter) Create(value interface{}) *MySQLService_Create_Call {
	return &MySQLService_Create_Call{Call: _e.mock.On("Create", value)}
}

func (_c *MySQLService_Create_Call) Run(run func(value interface{})) *MySQLService_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MySQLService_Create_Call) Return(tx *gorm.DB) *MySQLService_Create_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Create_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MySQLService_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInBatches provides a mock function with given fields: value, batchSize
func (_m *MySQLService) CreateInBatches(value interface{}, batchSize int) *gorm.DB {
	ret := _m.Called(value, batchSize)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, int) *gorm.DB); ok {
		r0 = rf(value, batchSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_CreateInBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInBatches'
type MySQLService_CreateInBatches_Call struct {
	*mock.Call
}

// CreateInBatches is a helper method to define mock.On call
//   - value interface{}
//   - batchSize int
func (_e *MySQLService_Expecter) CreateInBatches(value interface{}, batchSize interface{}) *MySQLService_CreateInBatches_Call {
	return &MySQLService_CreateInBatches_Call{Call: _e.mock.On("CreateInBatches", value, batchSize)}
}

func (_c *MySQLService_CreateInBatches_Call) Run(run func(value interface{}, batchSize int)) *MySQLService_CreateInBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(int))
	})
	return _c
}

func (_c *MySQLService_CreateInBatches_Call) Return(tx *gorm.DB) *MySQLService_CreateInBatches_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_CreateInBatches_Call) RunAndReturn(run func(interface{}, int) *gorm.DB) *MySQLService_CreateInBatches_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: value, conds
func (_m *MySQLService) Delete(value interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(value, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MySQLService_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - value interface{}
//   - conds ...interface{}
func (_e *MySQLService_Expecter) Delete(value interface{}, conds ...interface{}) *MySQLService_Delete_Call {
	return &MySQLService_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{value}, conds...)...)}
}

func (_c *MySQLService_Delete_Call) Run(run func(value interface{}, conds ...interface{})) *MySQLService_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_Delete_Call) Return(tx *gorm.DB) *MySQLService_Delete_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Delete_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MySQLService_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: _a0, values
func (_m *MySQLService) Exec(_a0 string, values ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *gorm.DB); ok {
		r0 = rf(_a0, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MySQLService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - _a0 string
//   - values ...interface{}
func (_e *MySQLService_Expecter) Exec(_a0 interface{}, values ...interface{}) *MySQLService_Exec_Call {
	return &MySQLService_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{_a0}, values...)...)}
}

func (_c *MySQLService_Exec_Call) Run(run func(_a0 string, values ...interface{})) *MySQLService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_Exec_Call) Return(tx *gorm.DB) *MySQLService_Exec_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Exec_Call) RunAndReturn(run func(string, ...interface{}) *gorm.DB) *MySQLService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: dest, conds
func (_m *MySQLService) Find(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type MySQLService_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MySQLService_Expecter) Find(dest interface{}, conds ...interface{}) *MySQLService_Find_Call {
	return &MySQLService_Find_Call{Call: _e.mock.On("Find",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MySQLService_Find_Call) Run(run func(dest interface{}, conds ...interface{})) *MySQLService_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_Find_Call) Return(tx *gorm.DB) *MySQLService_Find_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Find_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MySQLService_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindInBatches provides a mock function with given fields: dest, batchSize, fc
func (_m *MySQLService) FindInBatches(dest interface{}, batchSize int, fc func(*gorm.DB, int) error) *gorm.DB {
	ret := _m.Called(dest, batchSize, fc)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, int, func(*gorm.DB, int) error) *gorm.DB); ok {
		r0 = rf(dest, batchSize, fc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_FindInBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindInBatches'
type MySQLService_FindInBatches_Call struct {
	*mock.Call
}

// FindInBatches is a helper method to define mock.On call
//   - dest interface{}
//   - batchSize int
//   - fc func(*gorm.DB , int) error
func (_e *MySQLService_Expecter) FindInBatches(dest interface{}, batchSize interface{}, fc interface{}) *MySQLService_FindInBatches_Call {
	return &MySQLService_FindInBatches_Call{Call: _e.mock.On("FindInBatches", dest, batchSize, fc)}
}

func (_c *MySQLService_FindInBatches_Call) Run(run func(dest interface{}, batchSize int, fc func(*gorm.DB, int) error)) *MySQLService_FindInBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(int), args[2].(func(*gorm.DB, int) error))
	})
	return _c
}

func (_c *MySQLService_FindInBatches_Call) Return(_a0 *gorm.DB) *MySQLService_FindInBatches_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MySQLService_FindInBatches_Call) RunAndReturn(run func(interface{}, int, func(*gorm.DB, int) error) *gorm.DB) *MySQLService_FindInBatches_Call {
	_c.Call.Return(run)
	return _c
}

// First provides a mock function with given fields: dest, conds
func (_m *MySQLService) First(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_First_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'First'
type MySQLService_First_Call struct {
	*mock.Call
}

// First is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MySQLService_Expecter) First(dest interface{}, conds ...interface{}) *MySQLService_First_Call {
	return &MySQLService_First_Call{Call: _e.mock.On("First",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MySQLService_First_Call) Run(run func(dest interface{}, conds ...interface{})) *MySQLService_First_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_First_Call) Return(tx *gorm.DB) *MySQLService_First_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_First_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MySQLService_First_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrCreate provides a mock function with given fields: dest, conds
func (_m *MySQLService) FirstOrCreate(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_FirstOrCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrCreate'
type MySQLService_FirstOrCreate_Call struct {
	*mock.Call
}

// FirstOrCreate is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MySQLService_Expecter) FirstOrCreate(dest interface{}, conds ...interface{}) *MySQLService_FirstOrCreate_Call {
	return &MySQLService_FirstOrCreate_Call{Call: _e.mock.On("FirstOrCreate",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MySQLService_FirstOrCreate_Call) Run(run func(dest interface{}, conds ...interface{})) *MySQLService_FirstOrCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_FirstOrCreate_Call) Return(tx *gorm.DB) *MySQLService_FirstOrCreate_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_FirstOrCreate_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MySQLService_FirstOrCreate_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrInit provides a mock function with given fields: dest, conds
func (_m *MySQLService) FirstOrInit(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_FirstOrInit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrInit'
type MySQLService_FirstOrInit_Call struct {
	*mock.Call
}

// FirstOrInit is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MySQLService_Expecter) FirstOrInit(dest interface{}, conds ...interface{}) *MySQLService_FirstOrInit_Call {
	return &MySQLService_FirstOrInit_Call{Call: _e.mock.On("FirstOrInit",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MySQLService_FirstOrInit_Call) Run(run func(dest interface{}, conds ...interface{})) *MySQLService_FirstOrInit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_FirstOrInit_Call) Return(tx *gorm.DB) *MySQLService_FirstOrInit_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_FirstOrInit_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MySQLService_FirstOrInit_Call {
	_c.Call.Return(run)
	return _c
}

// Last provides a mock function with given fields: dest, conds
func (_m *MySQLService) Last(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Last_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Last'
type MySQLService_Last_Call struct {
	*mock.Call
}

// Last is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MySQLService_Expecter) Last(dest interface{}, conds ...interface{}) *MySQLService_Last_Call {
	return &MySQLService_Last_Call{Call: _e.mock.On("Last",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MySQLService_Last_Call) Run(run func(dest interface{}, conds ...interface{})) *MySQLService_Last_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_Last_Call) Return(tx *gorm.DB) *MySQLService_Last_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Last_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MySQLService_Last_Call {
	_c.Call.Return(run)
	return _c
}

// Pluck provides a mock function with given fields: column, dest
func (_m *MySQLService) Pluck(column string, dest interface{}) *gorm.DB {
	ret := _m.Called(column, dest)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Pluck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pluck'
type MySQLService_Pluck_Call struct {
	*mock.Call
}

// Pluck is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *MySQLService_Expecter) Pluck(column interface{}, dest interface{}) *MySQLService_Pluck_Call {
	return &MySQLService_Pluck_Call{Call: _e.mock.On("Pluck", column, dest)}
}

func (_c *MySQLService_Pluck_Call) Run(run func(column string, dest interface{})) *MySQLService_Pluck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MySQLService_Pluck_Call) Return(tx *gorm.DB) *MySQLService_Pluck_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Pluck_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *MySQLService_Pluck_Call {
	_c.Call.Return(run)
	return _c
}

// Rollback provides a mock function with given fields:
func (_m *MySQLService) Rollback() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Rollback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rollback'
type MySQLService_Rollback_Call struct {
	*mock.Call
}

// Rollback is a helper method to define mock.On call
func (_e *MySQLService_Expecter) Rollback() *MySQLService_Rollback_Call {
	return &MySQLService_Rollback_Call{Call: _e.mock.On("Rollback")}
}

func (_c *MySQLService_Rollback_Call) Run(run func()) *MySQLService_Rollback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MySQLService_Rollback_Call) Return(_a0 *gorm.DB) *MySQLService_Rollback_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MySQLService_Rollback_Call) RunAndReturn(run func() *gorm.DB) *MySQLService_Rollback_Call {
	_c.Call.Return(run)
	return _c
}

// RollbackTo provides a mock function with given fields: name
func (_m *MySQLService) RollbackTo(name string) *gorm.DB {
	ret := _m.Called(name)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string) *gorm.DB); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_RollbackTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RollbackTo'
type MySQLService_RollbackTo_Call struct {
	*mock.Call
}

// RollbackTo is a helper method to define mock.On call
//   - name string
func (_e *MySQLService_Expecter) RollbackTo(name interface{}) *MySQLService_RollbackTo_Call {
	return &MySQLService_RollbackTo_Call{Call: _e.mock.On("RollbackTo", name)}
}

func (_c *MySQLService_RollbackTo_Call) Run(run func(name string)) *MySQLService_RollbackTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MySQLService_RollbackTo_Call) Return(_a0 *gorm.DB) *MySQLService_RollbackTo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MySQLService_RollbackTo_Call) RunAndReturn(run func(string) *gorm.DB) *MySQLService_RollbackTo_Call {
	_c.Call.Return(run)
	return _c
}

// Row provides a mock function with given fields:
func (_m *MySQLService) Row() *sql.Row {
	ret := _m.Called()

	var r0 *sql.Row
	if rf, ok := ret.Get(0).(func() *sql.Row); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Row)
		}
	}

	return r0
}

// MySQLService_Row_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Row'
type MySQLService_Row_Call struct {
	*mock.Call
}

// Row is a helper method to define mock.On call
func (_e *MySQLService_Expecter) Row() *MySQLService_Row_Call {
	return &MySQLService_Row_Call{Call: _e.mock.On("Row")}
}

func (_c *MySQLService_Row_Call) Run(run func()) *MySQLService_Row_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MySQLService_Row_Call) Return(_a0 *sql.Row) *MySQLService_Row_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MySQLService_Row_Call) RunAndReturn(run func() *sql.Row) *MySQLService_Row_Call {
	_c.Call.Return(run)
	return _c
}

// Rows provides a mock function with given fields:
func (_m *MySQLService) Rows() (*sql.Rows, error) {
	ret := _m.Called()

	var r0 *sql.Rows
	var r1 error
	if rf, ok := ret.Get(0).(func() (*sql.Rows, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *sql.Rows); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Rows)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MySQLService_Rows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rows'
type MySQLService_Rows_Call struct {
	*mock.Call
}

// Rows is a helper method to define mock.On call
func (_e *MySQLService_Expecter) Rows() *MySQLService_Rows_Call {
	return &MySQLService_Rows_Call{Call: _e.mock.On("Rows")}
}

func (_c *MySQLService_Rows_Call) Run(run func()) *MySQLService_Rows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MySQLService_Rows_Call) Return(_a0 *sql.Rows, _a1 error) *MySQLService_Rows_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MySQLService_Rows_Call) RunAndReturn(run func() (*sql.Rows, error)) *MySQLService_Rows_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: value
func (_m *MySQLService) Save(value interface{}) *gorm.DB {
	ret := _m.Called(value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MySQLService_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - value interface{}
func (_e *MySQLService_Expecter) Save(value interface{}) *MySQLService_Save_Call {
	return &MySQLService_Save_Call{Call: _e.mock.On("Save", value)}
}

func (_c *MySQLService_Save_Call) Run(run func(value interface{})) *MySQLService_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MySQLService_Save_Call) Return(tx *gorm.DB) *MySQLService_Save_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Save_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MySQLService_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SavePoint provides a mock function with given fields: name
func (_m *MySQLService) SavePoint(name string) *gorm.DB {
	ret := _m.Called(name)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string) *gorm.DB); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_SavePoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SavePoint'
type MySQLService_SavePoint_Call struct {
	*mock.Call
}

// SavePoint is a helper method to define mock.On call
//   - name string
func (_e *MySQLService_Expecter) SavePoint(name interface{}) *MySQLService_SavePoint_Call {
	return &MySQLService_SavePoint_Call{Call: _e.mock.On("SavePoint", name)}
}

func (_c *MySQLService_SavePoint_Call) Run(run func(name string)) *MySQLService_SavePoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MySQLService_SavePoint_Call) Return(_a0 *gorm.DB) *MySQLService_SavePoint_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MySQLService_SavePoint_Call) RunAndReturn(run func(string) *gorm.DB) *MySQLService_SavePoint_Call {
	_c.Call.Return(run)
	return _c
}

// Scan provides a mock function with given fields: dest
func (_m *MySQLService) Scan(dest interface{}) *gorm.DB {
	ret := _m.Called(dest)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Scan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scan'
type MySQLService_Scan_Call struct {
	*mock.Call
}

// Scan is a helper method to define mock.On call
//   - dest interface{}
func (_e *MySQLService_Expecter) Scan(dest interface{}) *MySQLService_Scan_Call {
	return &MySQLService_Scan_Call{Call: _e.mock.On("Scan", dest)}
}

func (_c *MySQLService_Scan_Call) Run(run func(dest interface{})) *MySQLService_Scan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MySQLService_Scan_Call) Return(tx *gorm.DB) *MySQLService_Scan_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Scan_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MySQLService_Scan_Call {
	_c.Call.Return(run)
	return _c
}

// ScanRows provides a mock function with given fields: rows, dest
func (_m *MySQLService) ScanRows(rows *sql.Rows, dest interface{}) error {
	ret := _m.Called(rows, dest)

	var r0 error
	if rf, ok := ret.Get(0).(func(*sql.Rows, interface{}) error); ok {
		r0 = rf(rows, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MySQLService_ScanRows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScanRows'
type MySQLService_ScanRows_Call struct {
	*mock.Call
}

// ScanRows is a helper method to define mock.On call
//   - rows *sql.Rows
//   - dest interface{}
func (_e *MySQLService_Expecter) ScanRows(rows interface{}, dest interface{}) *MySQLService_ScanRows_Call {
	return &MySQLService_ScanRows_Call{Call: _e.mock.On("ScanRows", rows, dest)}
}

func (_c *MySQLService_ScanRows_Call) Run(run func(rows *sql.Rows, dest interface{})) *MySQLService_ScanRows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*sql.Rows), args[1].(interface{}))
	})
	return _c
}

func (_c *MySQLService_ScanRows_Call) Return(_a0 error) *MySQLService_ScanRows_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MySQLService_ScanRows_Call) RunAndReturn(run func(*sql.Rows, interface{}) error) *MySQLService_ScanRows_Call {
	_c.Call.Return(run)
	return _c
}

// Take provides a mock function with given fields: dest, conds
func (_m *MySQLService) Take(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Take_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Take'
type MySQLService_Take_Call struct {
	*mock.Call
}

// Take is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MySQLService_Expecter) Take(dest interface{}, conds ...interface{}) *MySQLService_Take_Call {
	return &MySQLService_Take_Call{Call: _e.mock.On("Take",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MySQLService_Take_Call) Run(run func(dest interface{}, conds ...interface{})) *MySQLService_Take_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_Take_Call) Return(tx *gorm.DB) *MySQLService_Take_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Take_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MySQLService_Take_Call {
	_c.Call.Return(run)
	return _c
}

// Transaction provides a mock function with given fields: fc, opts
func (_m *MySQLService) Transaction(fc func(*gorm.DB) error, opts ...*sql.TxOptions) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fc)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*gorm.DB) error, ...*sql.TxOptions) error); ok {
		r0 = rf(fc, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MySQLService_Transaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transaction'
type MySQLService_Transaction_Call struct {
	*mock.Call
}

// Transaction is a helper method to define mock.On call
//   - fc func(*gorm.DB) error
//   - opts ...*sql.TxOptions
func (_e *MySQLService_Expecter) Transaction(fc interface{}, opts ...interface{}) *MySQLService_Transaction_Call {
	return &MySQLService_Transaction_Call{Call: _e.mock.On("Transaction",
		append([]interface{}{fc}, opts...)...)}
}

func (_c *MySQLService_Transaction_Call) Run(run func(fc func(*gorm.DB) error, opts ...*sql.TxOptions)) *MySQLService_Transaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*sql.TxOptions, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*sql.TxOptions)
			}
		}
		run(args[0].(func(*gorm.DB) error), variadicArgs...)
	})
	return _c
}

func (_c *MySQLService_Transaction_Call) Return(err error) *MySQLService_Transaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MySQLService_Transaction_Call) RunAndReturn(run func(func(*gorm.DB) error, ...*sql.TxOptions) error) *MySQLService_Transaction_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: column, value
func (_m *MySQLService) Update(column string, value interface{}) *gorm.DB {
	ret := _m.Called(column, value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MySQLService_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *MySQLService_Expecter) Update(column interface{}, value interface{}) *MySQLService_Update_Call {
	return &MySQLService_Update_Call{Call: _e.mock.On("Update", column, value)}
}

func (_c *MySQLService_Update_Call) Run(run func(column string, value interface{})) *MySQLService_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MySQLService_Update_Call) Return(tx *gorm.DB) *MySQLService_Update_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Update_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *MySQLService_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateColumn provides a mock function with given fields: column, value
func (_m *MySQLService) UpdateColumn(column string, value interface{}) *gorm.DB {
	ret := _m.Called(column, value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_UpdateColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateColumn'
type MySQLService_UpdateColumn_Call struct {
	*mock.Call
}

// UpdateColumn is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *MySQLService_Expecter) UpdateColumn(column interface{}, value interface{}) *MySQLService_UpdateColumn_Call {
	return &MySQLService_UpdateColumn_Call{Call: _e.mock.On("UpdateColumn", column, value)}
}

func (_c *MySQLService_UpdateColumn_Call) Run(run func(column string, value interface{})) *MySQLService_UpdateColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MySQLService_UpdateColumn_Call) Return(tx *gorm.DB) *MySQLService_UpdateColumn_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_UpdateColumn_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *MySQLService_UpdateColumn_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateColumns provides a mock function with given fields: values
func (_m *MySQLService) UpdateColumns(values interface{}) *gorm.DB {
	ret := _m.Called(values)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_UpdateColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateColumns'
type MySQLService_UpdateColumns_Call struct {
	*mock.Call
}

// UpdateColumns is a helper method to define mock.On call
//   - values interface{}
func (_e *MySQLService_Expecter) UpdateColumns(values interface{}) *MySQLService_UpdateColumns_Call {
	return &MySQLService_UpdateColumns_Call{Call: _e.mock.On("UpdateColumns", values)}
}

func (_c *MySQLService_UpdateColumns_Call) Run(run func(values interface{})) *MySQLService_UpdateColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MySQLService_UpdateColumns_Call) Return(tx *gorm.DB) *MySQLService_UpdateColumns_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_UpdateColumns_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MySQLService_UpdateColumns_Call {
	_c.Call.Return(run)
	return _c
}

// Updates provides a mock function with given fields: values
func (_m *MySQLService) Updates(values interface{}) *gorm.DB {
	ret := _m.Called(values)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MySQLService_Updates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Updates'
type MySQLService_Updates_Call struct {
	*mock.Call
}

// Updates is a helper method to define mock.On call
//   - values interface{}
func (_e *MySQLService_Expecter) Updates(values interface{}) *MySQLService_Updates_Call {
	return &MySQLService_Updates_Call{Call: _e.mock.On("Updates", values)}
}

func (_c *MySQLService_Updates_Call) Run(run func(values interface{})) *MySQLService_Updates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MySQLService_Updates_Call) Return(tx *gorm.DB) *MySQLService_Updates_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MySQLService_Updates_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MySQLService_Updates_Call {
	_c.Call.Return(run)
	return _c
}

// NewMySQLService creates a new instance of MySQLService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMySQLService(t interface {
	mock.TestingT
	Cleanup(func())
},
) *MySQLService {
	mock := &MySQLService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
