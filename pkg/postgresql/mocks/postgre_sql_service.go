// Code generated by mockery v2.35.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gorm "gorm.io/gorm"

	sql "database/sql"
)

// PostgreSQLService is an autogenerated mock type for the PostgreSQLService type
type PostgreSQLService struct {
	mock.Mock
}

type PostgreSQLService_Expecter struct {
	mock *mock.Mock
}

func (_m *PostgreSQLService) EXPECT() *PostgreSQLService_Expecter {
	return &PostgreSQLService_Expecter{mock: &_m.Mock}
}

// Begin provides a mock function with given fields: opts
func (_m *PostgreSQLService) Begin(opts ...*sql.TxOptions) *gorm.DB {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...*sql.TxOptions) *gorm.DB); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Begin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Begin'
type PostgreSQLService_Begin_Call struct {
	*mock.Call
}

// Begin is a helper method to define mock.On call
//   - opts ...*sql.TxOptions
func (_e *PostgreSQLService_Expecter) Begin(opts ...interface{}) *PostgreSQLService_Begin_Call {
	return &PostgreSQLService_Begin_Call{Call: _e.mock.On("Begin",
		append([]interface{}{}, opts...)...)}
}

func (_c *PostgreSQLService_Begin_Call) Run(run func(opts ...*sql.TxOptions)) *PostgreSQLService_Begin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*sql.TxOptions, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(*sql.TxOptions)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_Begin_Call) Return(_a0 *gorm.DB) *PostgreSQLService_Begin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PostgreSQLService_Begin_Call) RunAndReturn(run func(...*sql.TxOptions) *gorm.DB) *PostgreSQLService_Begin_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields:
func (_m *PostgreSQLService) Commit() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type PostgreSQLService_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *PostgreSQLService_Expecter) Commit() *PostgreSQLService_Commit_Call {
	return &PostgreSQLService_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *PostgreSQLService_Commit_Call) Run(run func()) *PostgreSQLService_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PostgreSQLService_Commit_Call) Return(_a0 *gorm.DB) *PostgreSQLService_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PostgreSQLService_Commit_Call) RunAndReturn(run func() *gorm.DB) *PostgreSQLService_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// Connection provides a mock function with given fields: fc
func (_m *PostgreSQLService) Connection(fc func(*gorm.DB) error) error {
	ret := _m.Called(fc)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*gorm.DB) error) error); ok {
		r0 = rf(fc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PostgreSQLService_Connection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connection'
type PostgreSQLService_Connection_Call struct {
	*mock.Call
}

// Connection is a helper method to define mock.On call
//   - fc func(*gorm.DB) error
func (_e *PostgreSQLService_Expecter) Connection(fc interface{}) *PostgreSQLService_Connection_Call {
	return &PostgreSQLService_Connection_Call{Call: _e.mock.On("Connection", fc)}
}

func (_c *PostgreSQLService_Connection_Call) Run(run func(fc func(*gorm.DB) error)) *PostgreSQLService_Connection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(*gorm.DB) error))
	})
	return _c
}

func (_c *PostgreSQLService_Connection_Call) Return(err error) *PostgreSQLService_Connection_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PostgreSQLService_Connection_Call) RunAndReturn(run func(func(*gorm.DB) error) error) *PostgreSQLService_Connection_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with given fields: count
func (_m *PostgreSQLService) Count(count *int64) *gorm.DB {
	ret := _m.Called(count)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(*int64) *gorm.DB); ok {
		r0 = rf(count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type PostgreSQLService_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - count *int64
func (_e *PostgreSQLService_Expecter) Count(count interface{}) *PostgreSQLService_Count_Call {
	return &PostgreSQLService_Count_Call{Call: _e.mock.On("Count", count)}
}

func (_c *PostgreSQLService_Count_Call) Run(run func(count *int64)) *PostgreSQLService_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*int64))
	})
	return _c
}

func (_c *PostgreSQLService_Count_Call) Return(tx *gorm.DB) *PostgreSQLService_Count_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Count_Call) RunAndReturn(run func(*int64) *gorm.DB) *PostgreSQLService_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: value
func (_m *PostgreSQLService) Create(value interface{}) *gorm.DB {
	ret := _m.Called(value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type PostgreSQLService_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - value interface{}
func (_e *PostgreSQLService_Expecter) Create(value interface{}) *PostgreSQLService_Create_Call {
	return &PostgreSQLService_Create_Call{Call: _e.mock.On("Create", value)}
}

func (_c *PostgreSQLService_Create_Call) Run(run func(value interface{})) *PostgreSQLService_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_Create_Call) Return(tx *gorm.DB) *PostgreSQLService_Create_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Create_Call) RunAndReturn(run func(interface{}) *gorm.DB) *PostgreSQLService_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInBatches provides a mock function with given fields: value, batchSize
func (_m *PostgreSQLService) CreateInBatches(value interface{}, batchSize int) *gorm.DB {
	ret := _m.Called(value, batchSize)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, int) *gorm.DB); ok {
		r0 = rf(value, batchSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_CreateInBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInBatches'
type PostgreSQLService_CreateInBatches_Call struct {
	*mock.Call
}

// CreateInBatches is a helper method to define mock.On call
//   - value interface{}
//   - batchSize int
func (_e *PostgreSQLService_Expecter) CreateInBatches(value interface{}, batchSize interface{}) *PostgreSQLService_CreateInBatches_Call {
	return &PostgreSQLService_CreateInBatches_Call{Call: _e.mock.On("CreateInBatches", value, batchSize)}
}

func (_c *PostgreSQLService_CreateInBatches_Call) Run(run func(value interface{}, batchSize int)) *PostgreSQLService_CreateInBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(int))
	})
	return _c
}

func (_c *PostgreSQLService_CreateInBatches_Call) Return(tx *gorm.DB) *PostgreSQLService_CreateInBatches_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_CreateInBatches_Call) RunAndReturn(run func(interface{}, int) *gorm.DB) *PostgreSQLService_CreateInBatches_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: value, conds
func (_m *PostgreSQLService) Delete(value interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(value, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type PostgreSQLService_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - value interface{}
//   - conds ...interface{}
func (_e *PostgreSQLService_Expecter) Delete(value interface{}, conds ...interface{}) *PostgreSQLService_Delete_Call {
	return &PostgreSQLService_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{value}, conds...)...)}
}

func (_c *PostgreSQLService_Delete_Call) Run(run func(value interface{}, conds ...interface{})) *PostgreSQLService_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_Delete_Call) Return(tx *gorm.DB) *PostgreSQLService_Delete_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Delete_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *PostgreSQLService_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: _a0, values
func (_m *PostgreSQLService) Exec(_a0 string, values ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *gorm.DB); ok {
		r0 = rf(_a0, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type PostgreSQLService_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - _a0 string
//   - values ...interface{}
func (_e *PostgreSQLService_Expecter) Exec(_a0 interface{}, values ...interface{}) *PostgreSQLService_Exec_Call {
	return &PostgreSQLService_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{_a0}, values...)...)}
}

func (_c *PostgreSQLService_Exec_Call) Run(run func(_a0 string, values ...interface{})) *PostgreSQLService_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_Exec_Call) Return(tx *gorm.DB) *PostgreSQLService_Exec_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Exec_Call) RunAndReturn(run func(string, ...interface{}) *gorm.DB) *PostgreSQLService_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: dest, conds
func (_m *PostgreSQLService) Find(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type PostgreSQLService_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *PostgreSQLService_Expecter) Find(dest interface{}, conds ...interface{}) *PostgreSQLService_Find_Call {
	return &PostgreSQLService_Find_Call{Call: _e.mock.On("Find",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *PostgreSQLService_Find_Call) Run(run func(dest interface{}, conds ...interface{})) *PostgreSQLService_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_Find_Call) Return(tx *gorm.DB) *PostgreSQLService_Find_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Find_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *PostgreSQLService_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindInBatches provides a mock function with given fields: dest, batchSize, fc
func (_m *PostgreSQLService) FindInBatches(dest interface{}, batchSize int, fc func(*gorm.DB, int) error) *gorm.DB {
	ret := _m.Called(dest, batchSize, fc)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, int, func(*gorm.DB, int) error) *gorm.DB); ok {
		r0 = rf(dest, batchSize, fc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_FindInBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindInBatches'
type PostgreSQLService_FindInBatches_Call struct {
	*mock.Call
}

// FindInBatches is a helper method to define mock.On call
//   - dest interface{}
//   - batchSize int
//   - fc func(*gorm.DB , int) error
func (_e *PostgreSQLService_Expecter) FindInBatches(dest interface{}, batchSize interface{}, fc interface{}) *PostgreSQLService_FindInBatches_Call {
	return &PostgreSQLService_FindInBatches_Call{Call: _e.mock.On("FindInBatches", dest, batchSize, fc)}
}

func (_c *PostgreSQLService_FindInBatches_Call) Run(run func(dest interface{}, batchSize int, fc func(*gorm.DB, int) error)) *PostgreSQLService_FindInBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(int), args[2].(func(*gorm.DB, int) error))
	})
	return _c
}

func (_c *PostgreSQLService_FindInBatches_Call) Return(_a0 *gorm.DB) *PostgreSQLService_FindInBatches_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PostgreSQLService_FindInBatches_Call) RunAndReturn(run func(interface{}, int, func(*gorm.DB, int) error) *gorm.DB) *PostgreSQLService_FindInBatches_Call {
	_c.Call.Return(run)
	return _c
}

// First provides a mock function with given fields: dest, conds
func (_m *PostgreSQLService) First(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_First_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'First'
type PostgreSQLService_First_Call struct {
	*mock.Call
}

// First is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *PostgreSQLService_Expecter) First(dest interface{}, conds ...interface{}) *PostgreSQLService_First_Call {
	return &PostgreSQLService_First_Call{Call: _e.mock.On("First",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *PostgreSQLService_First_Call) Run(run func(dest interface{}, conds ...interface{})) *PostgreSQLService_First_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_First_Call) Return(tx *gorm.DB) *PostgreSQLService_First_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_First_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *PostgreSQLService_First_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrCreate provides a mock function with given fields: dest, conds
func (_m *PostgreSQLService) FirstOrCreate(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_FirstOrCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrCreate'
type PostgreSQLService_FirstOrCreate_Call struct {
	*mock.Call
}

// FirstOrCreate is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *PostgreSQLService_Expecter) FirstOrCreate(dest interface{}, conds ...interface{}) *PostgreSQLService_FirstOrCreate_Call {
	return &PostgreSQLService_FirstOrCreate_Call{Call: _e.mock.On("FirstOrCreate",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *PostgreSQLService_FirstOrCreate_Call) Run(run func(dest interface{}, conds ...interface{})) *PostgreSQLService_FirstOrCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_FirstOrCreate_Call) Return(tx *gorm.DB) *PostgreSQLService_FirstOrCreate_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_FirstOrCreate_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *PostgreSQLService_FirstOrCreate_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrInit provides a mock function with given fields: dest, conds
func (_m *PostgreSQLService) FirstOrInit(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_FirstOrInit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrInit'
type PostgreSQLService_FirstOrInit_Call struct {
	*mock.Call
}

// FirstOrInit is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *PostgreSQLService_Expecter) FirstOrInit(dest interface{}, conds ...interface{}) *PostgreSQLService_FirstOrInit_Call {
	return &PostgreSQLService_FirstOrInit_Call{Call: _e.mock.On("FirstOrInit",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *PostgreSQLService_FirstOrInit_Call) Run(run func(dest interface{}, conds ...interface{})) *PostgreSQLService_FirstOrInit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_FirstOrInit_Call) Return(tx *gorm.DB) *PostgreSQLService_FirstOrInit_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_FirstOrInit_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *PostgreSQLService_FirstOrInit_Call {
	_c.Call.Return(run)
	return _c
}

// Last provides a mock function with given fields: dest, conds
func (_m *PostgreSQLService) Last(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Last_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Last'
type PostgreSQLService_Last_Call struct {
	*mock.Call
}

// Last is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *PostgreSQLService_Expecter) Last(dest interface{}, conds ...interface{}) *PostgreSQLService_Last_Call {
	return &PostgreSQLService_Last_Call{Call: _e.mock.On("Last",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *PostgreSQLService_Last_Call) Run(run func(dest interface{}, conds ...interface{})) *PostgreSQLService_Last_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_Last_Call) Return(tx *gorm.DB) *PostgreSQLService_Last_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Last_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *PostgreSQLService_Last_Call {
	_c.Call.Return(run)
	return _c
}

// Pluck provides a mock function with given fields: column, dest
func (_m *PostgreSQLService) Pluck(column string, dest interface{}) *gorm.DB {
	ret := _m.Called(column, dest)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Pluck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pluck'
type PostgreSQLService_Pluck_Call struct {
	*mock.Call
}

// Pluck is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *PostgreSQLService_Expecter) Pluck(column interface{}, dest interface{}) *PostgreSQLService_Pluck_Call {
	return &PostgreSQLService_Pluck_Call{Call: _e.mock.On("Pluck", column, dest)}
}

func (_c *PostgreSQLService_Pluck_Call) Run(run func(column string, dest interface{})) *PostgreSQLService_Pluck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_Pluck_Call) Return(tx *gorm.DB) *PostgreSQLService_Pluck_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Pluck_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *PostgreSQLService_Pluck_Call {
	_c.Call.Return(run)
	return _c
}

// Rollback provides a mock function with given fields:
func (_m *PostgreSQLService) Rollback() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Rollback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rollback'
type PostgreSQLService_Rollback_Call struct {
	*mock.Call
}

// Rollback is a helper method to define mock.On call
func (_e *PostgreSQLService_Expecter) Rollback() *PostgreSQLService_Rollback_Call {
	return &PostgreSQLService_Rollback_Call{Call: _e.mock.On("Rollback")}
}

func (_c *PostgreSQLService_Rollback_Call) Run(run func()) *PostgreSQLService_Rollback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PostgreSQLService_Rollback_Call) Return(_a0 *gorm.DB) *PostgreSQLService_Rollback_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PostgreSQLService_Rollback_Call) RunAndReturn(run func() *gorm.DB) *PostgreSQLService_Rollback_Call {
	_c.Call.Return(run)
	return _c
}

// RollbackTo provides a mock function with given fields: name
func (_m *PostgreSQLService) RollbackTo(name string) *gorm.DB {
	ret := _m.Called(name)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string) *gorm.DB); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_RollbackTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RollbackTo'
type PostgreSQLService_RollbackTo_Call struct {
	*mock.Call
}

// RollbackTo is a helper method to define mock.On call
//   - name string
func (_e *PostgreSQLService_Expecter) RollbackTo(name interface{}) *PostgreSQLService_RollbackTo_Call {
	return &PostgreSQLService_RollbackTo_Call{Call: _e.mock.On("RollbackTo", name)}
}

func (_c *PostgreSQLService_RollbackTo_Call) Run(run func(name string)) *PostgreSQLService_RollbackTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *PostgreSQLService_RollbackTo_Call) Return(_a0 *gorm.DB) *PostgreSQLService_RollbackTo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PostgreSQLService_RollbackTo_Call) RunAndReturn(run func(string) *gorm.DB) *PostgreSQLService_RollbackTo_Call {
	_c.Call.Return(run)
	return _c
}

// Row provides a mock function with given fields:
func (_m *PostgreSQLService) Row() *sql.Row {
	ret := _m.Called()

	var r0 *sql.Row
	if rf, ok := ret.Get(0).(func() *sql.Row); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Row)
		}
	}

	return r0
}

// PostgreSQLService_Row_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Row'
type PostgreSQLService_Row_Call struct {
	*mock.Call
}

// Row is a helper method to define mock.On call
func (_e *PostgreSQLService_Expecter) Row() *PostgreSQLService_Row_Call {
	return &PostgreSQLService_Row_Call{Call: _e.mock.On("Row")}
}

func (_c *PostgreSQLService_Row_Call) Run(run func()) *PostgreSQLService_Row_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PostgreSQLService_Row_Call) Return(_a0 *sql.Row) *PostgreSQLService_Row_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PostgreSQLService_Row_Call) RunAndReturn(run func() *sql.Row) *PostgreSQLService_Row_Call {
	_c.Call.Return(run)
	return _c
}

// Rows provides a mock function with given fields:
func (_m *PostgreSQLService) Rows() (*sql.Rows, error) {
	ret := _m.Called()

	var r0 *sql.Rows
	var r1 error
	if rf, ok := ret.Get(0).(func() (*sql.Rows, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *sql.Rows); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Rows)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PostgreSQLService_Rows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rows'
type PostgreSQLService_Rows_Call struct {
	*mock.Call
}

// Rows is a helper method to define mock.On call
func (_e *PostgreSQLService_Expecter) Rows() *PostgreSQLService_Rows_Call {
	return &PostgreSQLService_Rows_Call{Call: _e.mock.On("Rows")}
}

func (_c *PostgreSQLService_Rows_Call) Run(run func()) *PostgreSQLService_Rows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PostgreSQLService_Rows_Call) Return(_a0 *sql.Rows, _a1 error) *PostgreSQLService_Rows_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PostgreSQLService_Rows_Call) RunAndReturn(run func() (*sql.Rows, error)) *PostgreSQLService_Rows_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: value
func (_m *PostgreSQLService) Save(value interface{}) *gorm.DB {
	ret := _m.Called(value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type PostgreSQLService_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - value interface{}
func (_e *PostgreSQLService_Expecter) Save(value interface{}) *PostgreSQLService_Save_Call {
	return &PostgreSQLService_Save_Call{Call: _e.mock.On("Save", value)}
}

func (_c *PostgreSQLService_Save_Call) Run(run func(value interface{})) *PostgreSQLService_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_Save_Call) Return(tx *gorm.DB) *PostgreSQLService_Save_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Save_Call) RunAndReturn(run func(interface{}) *gorm.DB) *PostgreSQLService_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SavePoint provides a mock function with given fields: name
func (_m *PostgreSQLService) SavePoint(name string) *gorm.DB {
	ret := _m.Called(name)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string) *gorm.DB); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_SavePoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SavePoint'
type PostgreSQLService_SavePoint_Call struct {
	*mock.Call
}

// SavePoint is a helper method to define mock.On call
//   - name string
func (_e *PostgreSQLService_Expecter) SavePoint(name interface{}) *PostgreSQLService_SavePoint_Call {
	return &PostgreSQLService_SavePoint_Call{Call: _e.mock.On("SavePoint", name)}
}

func (_c *PostgreSQLService_SavePoint_Call) Run(run func(name string)) *PostgreSQLService_SavePoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *PostgreSQLService_SavePoint_Call) Return(_a0 *gorm.DB) *PostgreSQLService_SavePoint_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PostgreSQLService_SavePoint_Call) RunAndReturn(run func(string) *gorm.DB) *PostgreSQLService_SavePoint_Call {
	_c.Call.Return(run)
	return _c
}

// Scan provides a mock function with given fields: dest
func (_m *PostgreSQLService) Scan(dest interface{}) *gorm.DB {
	ret := _m.Called(dest)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Scan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scan'
type PostgreSQLService_Scan_Call struct {
	*mock.Call
}

// Scan is a helper method to define mock.On call
//   - dest interface{}
func (_e *PostgreSQLService_Expecter) Scan(dest interface{}) *PostgreSQLService_Scan_Call {
	return &PostgreSQLService_Scan_Call{Call: _e.mock.On("Scan", dest)}
}

func (_c *PostgreSQLService_Scan_Call) Run(run func(dest interface{})) *PostgreSQLService_Scan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_Scan_Call) Return(tx *gorm.DB) *PostgreSQLService_Scan_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Scan_Call) RunAndReturn(run func(interface{}) *gorm.DB) *PostgreSQLService_Scan_Call {
	_c.Call.Return(run)
	return _c
}

// ScanRows provides a mock function with given fields: rows, dest
func (_m *PostgreSQLService) ScanRows(rows *sql.Rows, dest interface{}) error {
	ret := _m.Called(rows, dest)

	var r0 error
	if rf, ok := ret.Get(0).(func(*sql.Rows, interface{}) error); ok {
		r0 = rf(rows, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PostgreSQLService_ScanRows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScanRows'
type PostgreSQLService_ScanRows_Call struct {
	*mock.Call
}

// ScanRows is a helper method to define mock.On call
//   - rows *sql.Rows
//   - dest interface{}
func (_e *PostgreSQLService_Expecter) ScanRows(rows interface{}, dest interface{}) *PostgreSQLService_ScanRows_Call {
	return &PostgreSQLService_ScanRows_Call{Call: _e.mock.On("ScanRows", rows, dest)}
}

func (_c *PostgreSQLService_ScanRows_Call) Run(run func(rows *sql.Rows, dest interface{})) *PostgreSQLService_ScanRows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*sql.Rows), args[1].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_ScanRows_Call) Return(_a0 error) *PostgreSQLService_ScanRows_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PostgreSQLService_ScanRows_Call) RunAndReturn(run func(*sql.Rows, interface{}) error) *PostgreSQLService_ScanRows_Call {
	_c.Call.Return(run)
	return _c
}

// Take provides a mock function with given fields: dest, conds
func (_m *PostgreSQLService) Take(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Take_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Take'
type PostgreSQLService_Take_Call struct {
	*mock.Call
}

// Take is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *PostgreSQLService_Expecter) Take(dest interface{}, conds ...interface{}) *PostgreSQLService_Take_Call {
	return &PostgreSQLService_Take_Call{Call: _e.mock.On("Take",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *PostgreSQLService_Take_Call) Run(run func(dest interface{}, conds ...interface{})) *PostgreSQLService_Take_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_Take_Call) Return(tx *gorm.DB) *PostgreSQLService_Take_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Take_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *PostgreSQLService_Take_Call {
	_c.Call.Return(run)
	return _c
}

// Transaction provides a mock function with given fields: fc, opts
func (_m *PostgreSQLService) Transaction(fc func(*gorm.DB) error, opts ...*sql.TxOptions) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fc)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*gorm.DB) error, ...*sql.TxOptions) error); ok {
		r0 = rf(fc, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PostgreSQLService_Transaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transaction'
type PostgreSQLService_Transaction_Call struct {
	*mock.Call
}

// Transaction is a helper method to define mock.On call
//   - fc func(*gorm.DB) error
//   - opts ...*sql.TxOptions
func (_e *PostgreSQLService_Expecter) Transaction(fc interface{}, opts ...interface{}) *PostgreSQLService_Transaction_Call {
	return &PostgreSQLService_Transaction_Call{Call: _e.mock.On("Transaction",
		append([]interface{}{fc}, opts...)...)}
}

func (_c *PostgreSQLService_Transaction_Call) Run(run func(fc func(*gorm.DB) error, opts ...*sql.TxOptions)) *PostgreSQLService_Transaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*sql.TxOptions, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*sql.TxOptions)
			}
		}
		run(args[0].(func(*gorm.DB) error), variadicArgs...)
	})
	return _c
}

func (_c *PostgreSQLService_Transaction_Call) Return(err error) *PostgreSQLService_Transaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PostgreSQLService_Transaction_Call) RunAndReturn(run func(func(*gorm.DB) error, ...*sql.TxOptions) error) *PostgreSQLService_Transaction_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: column, value
func (_m *PostgreSQLService) Update(column string, value interface{}) *gorm.DB {
	ret := _m.Called(column, value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type PostgreSQLService_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *PostgreSQLService_Expecter) Update(column interface{}, value interface{}) *PostgreSQLService_Update_Call {
	return &PostgreSQLService_Update_Call{Call: _e.mock.On("Update", column, value)}
}

func (_c *PostgreSQLService_Update_Call) Run(run func(column string, value interface{})) *PostgreSQLService_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_Update_Call) Return(tx *gorm.DB) *PostgreSQLService_Update_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Update_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *PostgreSQLService_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateColumn provides a mock function with given fields: column, value
func (_m *PostgreSQLService) UpdateColumn(column string, value interface{}) *gorm.DB {
	ret := _m.Called(column, value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_UpdateColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateColumn'
type PostgreSQLService_UpdateColumn_Call struct {
	*mock.Call
}

// UpdateColumn is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *PostgreSQLService_Expecter) UpdateColumn(column interface{}, value interface{}) *PostgreSQLService_UpdateColumn_Call {
	return &PostgreSQLService_UpdateColumn_Call{Call: _e.mock.On("UpdateColumn", column, value)}
}

func (_c *PostgreSQLService_UpdateColumn_Call) Run(run func(column string, value interface{})) *PostgreSQLService_UpdateColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_UpdateColumn_Call) Return(tx *gorm.DB) *PostgreSQLService_UpdateColumn_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_UpdateColumn_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *PostgreSQLService_UpdateColumn_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateColumns provides a mock function with given fields: values
func (_m *PostgreSQLService) UpdateColumns(values interface{}) *gorm.DB {
	ret := _m.Called(values)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_UpdateColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateColumns'
type PostgreSQLService_UpdateColumns_Call struct {
	*mock.Call
}

// UpdateColumns is a helper method to define mock.On call
//   - values interface{}
func (_e *PostgreSQLService_Expecter) UpdateColumns(values interface{}) *PostgreSQLService_UpdateColumns_Call {
	return &PostgreSQLService_UpdateColumns_Call{Call: _e.mock.On("UpdateColumns", values)}
}

func (_c *PostgreSQLService_UpdateColumns_Call) Run(run func(values interface{})) *PostgreSQLService_UpdateColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_UpdateColumns_Call) Return(tx *gorm.DB) *PostgreSQLService_UpdateColumns_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_UpdateColumns_Call) RunAndReturn(run func(interface{}) *gorm.DB) *PostgreSQLService_UpdateColumns_Call {
	_c.Call.Return(run)
	return _c
}

// Updates provides a mock function with given fields: values
func (_m *PostgreSQLService) Updates(values interface{}) *gorm.DB {
	ret := _m.Called(values)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// PostgreSQLService_Updates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Updates'
type PostgreSQLService_Updates_Call struct {
	*mock.Call
}

// Updates is a helper method to define mock.On call
//   - values interface{}
func (_e *PostgreSQLService_Expecter) Updates(values interface{}) *PostgreSQLService_Updates_Call {
	return &PostgreSQLService_Updates_Call{Call: _e.mock.On("Updates", values)}
}

func (_c *PostgreSQLService_Updates_Call) Run(run func(values interface{})) *PostgreSQLService_Updates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *PostgreSQLService_Updates_Call) Return(tx *gorm.DB) *PostgreSQLService_Updates_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *PostgreSQLService_Updates_Call) RunAndReturn(run func(interface{}) *gorm.DB) *PostgreSQLService_Updates_Call {
	_c.Call.Return(run)
	return _c
}

// NewPostgreSQLService creates a new instance of PostgreSQLService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPostgreSQLService(t interface {
	mock.TestingT
	Cleanup(func())
},
) *PostgreSQLService {
	mock := &PostgreSQLService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
